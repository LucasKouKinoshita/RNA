plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,-2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,-3], col = 'red')
lines(t, X[,3], col = 'red')
lines(t, X[,2], col = 'purple')
lines(t, X[,-1], col = 'blue')
<- as.matrix(read.table('dados/t'))
t <- as.matrix(read.table('dados/t'))
X <- as.matrix(read.table('dados/x'))
Y <- as.matrix(read.table('dados/y'))
t_seq <- seq(min(t), max(t), by = 0.2) # Amostragem mais fina
Xt1 <- 1.4 * sin(pi/3.15 * t_seq)  # Sinal seno escalado para alcançar 1.5 no pico
Xt1 <- as.matrix(Xt1)  # Convertendo para matriz
Xt2 <- 1.4* cos(pi/3.15 * t_seq)
Xt2 <- as.matrix(Xt2)
Xt3 <- t_seq - 1.5  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.5*t_seq - 1.5  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.4*t_seq - 1.5  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.6*t_seq - 1.5  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.45*t_seq - 1.5  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.55*t_seq - 1.5  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.55*t_seq - 1.6  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.55*t_seq - 1.8  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
Xt3 <- 0.54*t_seq - 1.8  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
graphics.off()
rm(list = ls())
library('corpcor')
adaline <- function(X, y, eta, tol, maxepocas, par) {
N <- nrow(X) # Número de linhas de X
n <- ncol(X)
error_curve <- numeric(maxepocas) # Vetor para armazenar o erro por época
# Inicializando pesos
if(par == 1){
w <- as.matrix(runif(n+1) - 0.5)
X <- cbind(1,X)
} else {
w <- as.matrix(runif(n) - 0.5)
}
nepocas <- 0
erroepoca <- tol + 1 # Inicializa erro acima do limite para entrar no loop
while (erroepoca > tol && nepocas < maxepocas) {
xseq <- sample(N) # Embaralha os índices
ei2 <- 0 # Inicializa erro da época
for (i in xseq) {
yhat <- 1*(t(w) %*%  X[i, ])
erro <- y[i] - yhat
dw <- eta * erro * X[i, ] # Atualização dos pesos
w <- w + dw
ei2 <- ei2 + erro^2 # Acumula erro quadrático
}
error_curve[nepocas] <- ei2 / N # Erro médio quadrático por época
nepocas <- nepocas + 1
}
list(weights = w, error = error_curve[1:(nepocas - 1)])
}
t <- as.matrix(read.table('dados/t'))
X <- as.matrix(read.table('dados/x'))
Y <- as.matrix(read.table('dados/y'))
t_seq <- seq(min(t), max(t), by = 0.2) # Amostragem mais fina
Xt1 <- 1.4 * sin(pi/3.15 * t_seq)  # Sinal seno escalado para alcançar 1.5 no pico
Xt1 <- as.matrix(Xt1)  # Convertendo para matriz
Xt2 <- 1.4* cos(pi/3.15 * t_seq)
Xt2 <- as.matrix(Xt2)
Xt3 <- 0.54*t_seq - 1.8  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando as previsões
# Preparando as matrizes de entrada
H <- cbind(X , 1)
Ht <- cbind(Xt1, Xt2, Xt3, 1)
# Parâmetros do Adaline
eta <- 1e-3
tol <- 1e-2
maxepocas <- 10000
adaline_model <- adaline(H, Y, eta, tol, maxepocas, par = 0)
# Extrair resultados
final_weights <- adaline_model$weights
error_curve <- adaline_model$error
# Plotando a curva de aprendizado
plot(error_curve, type = "l", col = "blue", lwd = 2,
xlab = "Épocas", ylab = "Erro Médio Quadrático",
main = "Curva de Aprendizado do Adaline")
# Fazendo previsões com os dados Xt
y_pred <- Ht %*% final_weights
# Plotando os resultados da previsão no grá original
plot(t, Y, col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Regressão com Adaline")
lines(t, Y, col = 'blue')
# Adicionando as previsões
points(t_seq, y_pred, col = "green", pch = 16)
lines(t_seq, y_pred, col = "green", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Y (Saída)", "Previsão Adaline"),
col = c("red", "blue", "green"),
pch = c(1, 16, 16), lty = c(1, 1, 1), lwd = c(NA, 2, 2))
# Plotando a avaliação com dados de teste (Xt)
plot(t_seq, Xt, col = "purple", pch = 16, xlab = "t", ylab = "Y", main = "Resposta a Novo Sinal")
graphics.off()
rm(list = ls())
library('corpcor')
adaline <- function(X, y, eta, tol, maxepocas, par) {
N <- nrow(X) # Número de linhas de X
n <- ncol(X)
error_curve <- numeric(maxepocas) # Vetor para armazenar o erro por época
# Inicializando pesos
if(par == 1){
w <- as.matrix(runif(n+1) - 0.5)
X <- cbind(1,X)
} else {
w <- as.matrix(runif(n) - 0.5)
}
nepocas <- 0
erroepoca <- tol + 1 # Inicializa erro acima do limite para entrar no loop
while (erroepoca > tol && nepocas < maxepocas) {
xseq <- sample(N) # Embaralha os índices
ei2 <- 0 # Inicializa erro da época
for (i in xseq) {
yhat <- 1*(t(w) %*%  X[i, ])
erro <- y[i] - yhat
dw <- eta * erro * X[i, ] # Atualização dos pesos
w <- w + dw
ei2 <- ei2 + erro^2 # Acumula erro quadrático
}
error_curve[nepocas] <- ei2 / N # Erro médio quadrático por época
nepocas <- nepocas + 1
}
list(weights = w, error = error_curve[1:(nepocas - 1)])
}
t <- as.matrix(read.table('dados/t'))
X <- as.matrix(read.table('dados/x'))
Y <- as.matrix(read.table('dados/y'))
t_seq <- seq(min(t), max(t), by = 0.2) # Amostragem mais fina
Xt1 <- 1.4 * sin(pi/3.15 * t_seq)  # Sinal seno escalado para alcançar 1.5 no pico
Xt1 <- as.matrix(Xt1)  # Convertendo para matriz
Xt2 <- 1.4* cos(pi/3.15 * t_seq)
Xt2 <- as.matrix(Xt2)
Xt3 <- 0.54*t_seq - 1.8  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Preparando as matrizes de entrada
H <- cbind(X , 1)
Ht <- cbind(Xt1, Xt2, Xt3, 1)
# Parâmetros do Adaline
eta <- 1e-3
tol <- 1e-2
maxepocas <- 10000
adaline_model <- adaline(H, Y, eta, tol, maxepocas, par = 0)
# Extrair resultados
final_weights <- adaline_model$weights
error_curve <- adaline_model$error
# Plotando a curva de aprendizado
plot(error_curve, type = "l", col = "blue", lwd = 2,
xlab = "Épocas", ylab = "Erro Médio Quadrático",
main = "Curva de Aprendizado do Adaline")
# Fazendo previsões com os dados Xt
y_pred <- Ht %*% final_weights
# Plotando os resultados da previsão no grá original
plot(t, Y, col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Regressão com Adaline")
lines(t, Y, col = 'blue')
# Adicionando as previsões
points(t_seq, y_pred, col = "green", pch = 16)
lines(t_seq, y_pred, col = "green", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Y (Saída)", "Previsão Adaline"),
col = c("blue", "green"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
t <- as.matrix(read.table('dados/t'))
X <- as.matrix(read.table('dados/x'))
Y <- as.matrix(read.table('dados/y'))
t_seq <- seq(min(t), max(t), by = 0.2) # Amostragem mais fina
Xt1 <- 1.4 * sin(pi/3.15 * t_seq)  # Sinal seno escalado para alcançar 1.5 no pico
Xt1 <- as.matrix(Xt1)  # Convertendo para matriz
Xt2 <- 1.4* cos(pi/3.15 * t_seq)
Xt2 <- as.matrix(Xt2)
Xt3 <- 0.54*t_seq - 1.8  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Xt"),
col = c("blue", "green"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Xt"),
col = c("purple", "yellow"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Xt"),
col = c("red", "black"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
graphics.off()
rm(list = ls())
library('corpcor')
adaline <- function(X, y, eta, tol, maxepocas, par) {
N <- nrow(X) # Número de linhas de X
n <- ncol(X)
error_curve <- numeric(maxepocas) # Vetor para armazenar o erro por época
# Inicializando pesos
if(par == 1){
w <- as.matrix(runif(n+1) - 0.5)
X <- cbind(1,X)
} else {
w <- as.matrix(runif(n) - 0.5)
}
nepocas <- 0
erroepoca <- tol + 1 # Inicializa erro acima do limite para entrar no loop
while (erroepoca > tol && nepocas < maxepocas) {
xseq <- sample(N) # Embaralha os índices
ei2 <- 0 # Inicializa erro da época
for (i in xseq) {
yhat <- 1*(t(w) %*%  X[i, ])
erro <- y[i] - yhat
dw <- eta * erro * X[i, ] # Atualização dos pesos
w <- w + dw
ei2 <- ei2 + erro^2 # Acumula erro quadrático
}
error_curve[nepocas] <- ei2 / N # Erro médio quadrático por época
nepocas <- nepocas + 1
}
list(weights = w, error = error_curve[1:(nepocas - 1)])
}
t <- as.matrix(read.table('dados/t'))
X <- as.matrix(read.table('dados/x'))
Y <- as.matrix(read.table('dados/y'))
t_seq <- seq(min(t), max(t), by = 0.2) # Amostragem mais fina
Xt1 <- 1.4 * sin(pi/3.15 * t_seq)
Xt1 <- as.matrix(Xt1)  # Convertendo para matriz
Xt2 <- 1.4* cos(pi/3.15 * t_seq)
Xt2 <- as.matrix(Xt2)
Xt3 <- 0.54*t_seq - 1.8  # Sinal seno
Xt3 <- as.matrix(Xt3)
plot(t, X[,1], col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 1")
lines(t, X[,1], col = 'blue')
points(t_seq, Xt1, col = "green", pch = 16)
lines(t_seq, Xt1, col = "green", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Xt"),
col = c("blue", "green"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
plot(t, X[,2], col = "purple", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 2")
lines(t, X[,2], col = 'purple')
points(t_seq, Xt2, col = "yellow", pch = 16)
lines(t_seq, Xt2, col = "yellow", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Xt"),
col = c("purple", "yellow"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
plot(t, X[,3], col = "red", pch = 1, xlab = "t",
ylab = "Y", main = "Entrada 3")
lines(t, X[,3], col = 'red')
points(t_seq, Xt3, col = "black", pch = 16)
lines(t_seq, Xt3, col = "black", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Xt"),
col = c("red", "black"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
# Preparando as matrizes de entrada
H <- cbind(X , 1)
Ht <- cbind(Xt1, Xt2, Xt3, 1)
# Parâmetros do Adaline
eta <- 1e-3
tol <- 1e-2
maxepocas <- 10000
adaline_model <- adaline(H, Y, eta, tol, maxepocas, par = 0)
# Extrair resultados
final_weights <- adaline_model$weights
error_curve <- adaline_model$error
# Plotando a curva de aprendizado
plot(error_curve, type = "l", col = "blue", lwd = 2,
xlab = "Épocas", ylab = "Erro Médio Quadrático",
main = "Curva de Aprendizado do Adaline")
# Fazendo previsões com os dados Xt
y_pred <- Ht %*% final_weights
# Plotando os resultados da previsão no grá original
plot(t, Y, col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Regressão com Adaline")
lines(t, Y, col = 'blue')
# Adicionando as previsões
points(t_seq, y_pred, col = "green", pch = 16)
lines(t_seq, y_pred, col = "green", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("X (Entrada)", "Y (Saída)", "Previsão Adaline"),
col = c("blue", "green"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
# Adicionando legendas
legend("bottomright",
legend = c("Y (Saída)", "Previsão Adaline"),
col = c("blue", "green"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
# Plotando os resultados da previsão no grá original
plot(t, Y, col = "blue", pch = 1, xlab = "t",
ylab = "Y", main = "Regressão com Adaline")
lines(t, Y, col = 'blue')
# Adicionando as previsões
points(t_seq, y_pred, col = "green", pch = 16)
lines(t_seq, y_pred, col = "green", lwd = 2)
# Adicionando legendas
legend("bottomright",
legend = c("Y (Saída)", "Previsão Adaline"),
col = c("blue", "green"),
pch = c(16, 16), lty = c(1, 1), lwd = c(2, 2))
